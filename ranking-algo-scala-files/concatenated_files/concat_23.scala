package com.twitter.cr_mixer.param

import com.twitter.timelines.configapi._

object RealGraphInParams {
  object EnableSourceGraphParam
      extends FSParam[Boolean](
        name = "graph_realgraphin_enable_source",
        default = false
      )

  val AllParams: Seq[Param[_] with FSName] = Seq(
    EnableSourceGraphParam,
  )

  lazy val config: BaseConfig = {
    val booleanOverrides = FeatureSwitchOverrideUtil.getBooleanFSOverrides(
      EnableSourceGraphParam
    )

    BaseConfigBuilder()
      .set(booleanOverrides: _*)
      .build()
  }
}
package com.twitter.cr_mixer.param

import com.twitter.timelines.configapi.BaseConfig
import com.twitter.timelines.configapi.BaseConfigBuilder
import com.twitter.timelines.configapi.FSName
import com.twitter.timelines.configapi.FSParam
import com.twitter.timelines.configapi.FeatureSwitchOverrideUtil
import com.twitter.timelines.configapi.Param

object RecentReplyTweetsParams {
  // Source params
  object EnableSourceParam
      extends FSParam[Boolean](
        name = "twistly_recentreplytweets_enable_source",
        default = false
      )

  val AllParams: Seq[Param[_] with FSName] = Seq(EnableSourceParam)

  lazy val config: BaseConfig = {
    val booleanOverrides = FeatureSwitchOverrideUtil.getBooleanFSOverrides(EnableSourceParam)

    BaseConfigBuilder()
      .set(booleanOverrides: _*)
      .build()
  }
}
package com.twitter.cr_mixer.model

import com.twitter.contentrecommender.thriftscala.TweetInfo
import com.twitter.cr_mixer.thriftscala.LineItemInfo
import com.twitter.simclusters_v2.common.TweetId

sealed trait Candidate {
  val tweetId: TweetId

  override def hashCode: Int = tweetId.toInt
}

case class TweetWithCandidateGenerationInfo(
  tweetId: TweetId,
  candidateGenerationInfo: CandidateGenerationInfo)
    extends Candidate {

  def getSimilarityScore: Double =
    candidateGenerationInfo.similarityEngineInfo.score.getOrElse(0.0)
}

case class InitialCandidate(
  tweetId: TweetId,
  tweetInfo: TweetInfo,
  candidateGenerationInfo: CandidateGenerationInfo)
    extends Candidate {

  /** *
   * Get the Similarity Score of a Tweet from its CG Info. For instance,
   * If it is from a UnifiedTweetBasedSimilarityEngine, the score will be the weighted combined score
   * And if it is from a SimClustersANNSimilarityEngine, the score will be the SANN score
   */
  def getSimilarityScore: Double =
    candidateGenerationInfo.similarityEngineInfo.score.getOrElse(0.0)

  /**
   * The same candidate can be generated by multiple algorithms.
   * During blending, candidate deduping happens. In order to retain the candidateGenerationInfo
   * from different algorithms, we attach them to a list of potentialReasons.
   */
  def toBlendedCandidate(
    potentialReasons: Seq[CandidateGenerationInfo],
  ): BlendedCandidate = {
    BlendedCandidate(
      tweetId,
      tweetInfo,
      candidateGenerationInfo,
      potentialReasons,
    )
  }

  // for experimental purposes only when bypassing interleave / ranking
  def toRankedCandidate(): RankedCandidate = {
    RankedCandidate(
      tweetId,
      tweetInfo,
      0.0, // prediction score is default to 0.0 to help differentiate that it is a no-op
      candidateGenerationInfo,
      Seq(candidateGenerationInfo)
    )
  }
}

case class InitialAdsCandidate(
  tweetId: TweetId,
  lineItemInfo: Seq[LineItemInfo],
  candidateGenerationInfo: CandidateGenerationInfo)
    extends Candidate {

  /** *
   * Get the Similarity Score of a Tweet from its CG Info. For instance,
   * If it is from a UnifiedTweetBasedSimilarityEngine, the score will be the weighted combined score
   * And if it is from a SimClustersANNSimilarityEngine, the score will be the SANN score
   */
  def getSimilarityScore: Double =
    candidateGenerationInfo.similarityEngineInfo.score.getOrElse(0.0)

  /**
   * The same candidate can be generated by multiple algorithms.
   * During blending, candidate deduping happens. In order to retain the candidateGenerationInfo
   * from different algorithms, we attach them to a list of potentialReasons.
   */
  def toBlendedAdsCandidate(
    potentialReasons: Seq[CandidateGenerationInfo],
  ): BlendedAdsCandidate = {
    BlendedAdsCandidate(
      tweetId,
      lineItemInfo,
      candidateGenerationInfo,
      potentialReasons,
    )
  }

  // for experimental purposes only when bypassing interleave / ranking
  def toRankedAdsCandidate(): RankedAdsCandidate = {
    RankedAdsCandidate(
      tweetId,
      lineItemInfo,
      0.0, // prediction score is default to 0.0 to help differentiate that it is a no-op
      candidateGenerationInfo,
      Seq(candidateGenerationInfo)
    )
  }
}

case class BlendedCandidate(
  tweetId: TweetId,
  tweetInfo: TweetInfo,
  reasonChosen: CandidateGenerationInfo,
  potentialReasons: Seq[CandidateGenerationInfo])
    extends Candidate {

  /** *
   * Get the Similarity Score of a Tweet from its CG Info. For instance,
   * If it is from a UnifiedTweetBasedSimilarityEngine, the score will be the weighted combined score
   * And if it is from a SimClustersANNSimilarityEngine, the score will be the SANN score
   */
  def getSimilarityScore: Double =
    reasonChosen.similarityEngineInfo.score.getOrElse(0.0)

  assert(potentialReasons.contains(reasonChosen))

  def toRankedCandidate(predictionScore: Double): RankedCandidate = {
    RankedCandidate(
      tweetId,
      tweetInfo,
      predictionScore,
      reasonChosen,
      potentialReasons
    )
  }
}

case class BlendedAdsCandidate(
  tweetId: TweetId,
  lineItemInfo: Seq[LineItemInfo],
  reasonChosen: CandidateGenerationInfo,
  potentialReasons: Seq[CandidateGenerationInfo])
    extends Candidate {

  /** *
   * Get the Similarity Score of a Tweet from its CG Info. For instance,
   * If it is from a UnifiedTweetBasedSimilarityEngine, the score will be the weighted combined score
   * And if it is from a SimClustersANNSimilarityEngine, the score will be the SANN score
   */
  def getSimilarityScore: Double =
    reasonChosen.similarityEngineInfo.score.getOrElse(0.0)

  assert(potentialReasons.contains(reasonChosen))

  def toRankedAdsCandidate(predictionScore: Double): RankedAdsCandidate = {
    RankedAdsCandidate(
      tweetId,
      lineItemInfo,
      predictionScore,
      reasonChosen,
      potentialReasons
    )
  }
}

case class RankedCandidate(
  tweetId: TweetId,
  tweetInfo: TweetInfo,
  predictionScore: Double,
  reasonChosen: CandidateGenerationInfo,
  potentialReasons: Seq[CandidateGenerationInfo])
    extends Candidate {

  /** *
   * Get the Similarity Score of a Tweet from its CG Info. For instance,
   * If it is from a UnifiedTweetBasedSimilarityEngine, the score will be the weighted combined score
   * And if it is from a SimClustersANNSimilarityEngine, the score will be the SANN score
   */
  def getSimilarityScore: Double =
    reasonChosen.similarityEngineInfo.score.getOrElse(0.0)

  assert(potentialReasons.contains(reasonChosen))
}

case class RankedAdsCandidate(
  tweetId: TweetId,
  lineItemInfo: Seq[LineItemInfo],
  predictionScore: Double,
  reasonChosen: CandidateGenerationInfo,
  potentialReasons: Seq[CandidateGenerationInfo])
    extends Candidate {

  /** *
   * Get the Similarity Score of a Tweet from its CG Info. For instance,
   * If it is from a UnifiedTweetBasedSimilarityEngine, the score will be the weighted combined score
   * And if it is from a SimClustersANNSimilarityEngine, the score will be the SANN score
   */
  def getSimilarityScore: Double =
    reasonChosen.similarityEngineInfo.score.getOrElse(0.0)

  assert(potentialReasons.contains(reasonChosen))
}

case class TripTweetWithScore(tweetId: TweetId, score: Double) extends Candidate
package com.twitter.cr_mixer.param

import com.twitter.timelines.configapi.BaseConfig
import com.twitter.timelines.configapi.BaseConfigBuilder
import com.twitter.timelines.configapi.FeatureSwitchOverrideUtil
import com.twitter.timelines.configapi.FSName
import com.twitter.timelines.configapi.FSParam
import com.twitter.timelines.configapi.Param

object VideoTweetFilterParams {

  object EnableVideoTweetFilterParam
      extends FSParam[Boolean](
        name = "video_tweet_filter_enable_filter",
        default = false
      )

  val AllParams: Seq[Param[_] with FSName] = Seq(
    EnableVideoTweetFilterParam
  )

  lazy val config: BaseConfig = {

    val booleanOverrides =
      FeatureSwitchOverrideUtil.getBooleanFSOverrides(EnableVideoTweetFilterParam)

    BaseConfigBuilder()
      .set(booleanOverrides: _*)
      .build()
  }
}
package com.twitter.cr_mixer.param

import com.twitter.timelines.configapi.BaseConfig
import com.twitter.timelines.configapi.BaseConfigBuilder
import com.twitter.timelines.configapi.FSName
import com.twitter.timelines.configapi.FSParam
import com.twitter.timelines.configapi.FeatureSwitchOverrideUtil
import com.twitter.timelines.configapi.Param

object RecentFollowsParams {
  object EnableSourceParam
      extends FSParam[Boolean](
        name = "twistly_recentfollows_enable_source",
        default = true
      )

  val AllParams: Seq[Param[_] with FSName] = Seq(EnableSourceParam)
  lazy val config: BaseConfig = {
    val booleanOverrides = FeatureSwitchOverrideUtil.getBooleanFSOverrides(
      EnableSourceParam
    )

    BaseConfigBuilder()
      .set(booleanOverrides: _*)
      .build()
  }
}
package com.twitter.cr_mixer.param

import com.twitter.cr_mixer.model.ModelConfig
import com.twitter.timelines.configapi.BaseConfig
import com.twitter.timelines.configapi.BaseConfigBuilder
import com.twitter.timelines.configapi.FSName
import com.twitter.timelines.configapi.FSParam
import com.twitter.timelines.configapi.FeatureSwitchOverrideUtil
import com.twitter.timelines.configapi.Param

object CustomizedRetrievalBasedTwhinParams {

  // Model slots available for TwhinCollab and MultiCluster
  object CustomizedRetrievalBasedTwhinCollabFilterFollowSource
      extends FSParam[String](
        name = "customized_retrieval_based_offline_twhin_collab_filter_follow_model_id",
        default = ModelConfig.TwhinCollabFilterForFollow
      )

  object CustomizedRetrievalBasedTwhinCollabFilterEngagementSource
      extends FSParam[String](
        name = "customized_retrieval_based_offline_twhin_collab_filter_engagement_model_id",
        default = ModelConfig.TwhinCollabFilterForEngagement
      )

  object CustomizedRetrievalBasedTwhinMultiClusterFollowSource
      extends FSParam[String](
        name = "customized_retrieval_based_offline_twhin_multi_cluster_follow_model_id",
        default = ModelConfig.TwhinMultiClusterForFollow
      )

  object CustomizedRetrievalBasedTwhinMultiClusterEngagementSource
      extends FSParam[String](
        name = "customized_retrieval_based_offline_twhin_multi_cluster_engagement_model_id",
        default = ModelConfig.TwhinMultiClusterForEngagement
      )

  val AllParams: Seq[Param[_] with FSName] =
    Seq(
      CustomizedRetrievalBasedTwhinCollabFilterFollowSource,
      CustomizedRetrievalBasedTwhinCollabFilterEngagementSource,
      CustomizedRetrievalBasedTwhinMultiClusterFollowSource,
      CustomizedRetrievalBasedTwhinMultiClusterEngagementSource,
    )

  lazy val config: BaseConfig = {

    val stringFSOverrides =
      FeatureSwitchOverrideUtil.getStringFSOverrides(
        CustomizedRetrievalBasedTwhinCollabFilterFollowSource,
        CustomizedRetrievalBasedTwhinCollabFilterEngagementSource,
        CustomizedRetrievalBasedTwhinMultiClusterFollowSource,
        CustomizedRetrievalBasedTwhinMultiClusterEngagementSource,
      )

    BaseConfigBuilder()
      .set(stringFSOverrides: _*)
      .build()
  }
}
package com.twitter.cr_mixer.param

import scala.language.implicitConversions

object UnifiedSETweetCombinationMethod extends Enumeration {

  protected case class CombinationType(s: String) extends super.Val

  implicit def valueToCombinationType(x: Value): CombinationType = x.asInstanceOf[CombinationType]

  val Default: Value = CombinationType("")
  val Interleave: Value = CombinationType("Interleave")
  val Frontload: Value = CombinationType("Frontload")
  val Backfill: Value = CombinationType("Backfill")
}
package com.twitter.cr_mixer.param

import com.twitter.cr_mixer.model.ModelConfig
import com.twitter.timelines.configapi.BaseConfig
import com.twitter.timelines.configapi.BaseConfigBuilder
import com.twitter.timelines.configapi.FSName
import com.twitter.timelines.configapi.FSParam
import com.twitter.timelines.configapi.FeatureSwitchOverrideUtil
import com.twitter.timelines.configapi.Param

object CustomizedRetrievalBasedOfflineInterestedInParams {

  // Model slots available for offline InterestedIn candidate generation
  object CustomizedRetrievalBasedOfflineInterestedInSource
      extends FSParam[String](
        name = "customized_retrieval_based_offline_interestedin_model_id",
        default = ModelConfig.OfflineInterestedInFromKnownFor2020
      )

  val AllParams: Seq[Param[_] with FSName] = Seq(CustomizedRetrievalBasedOfflineInterestedInSource)

  lazy val config: BaseConfig = {

    val stringFSOverrides =
      FeatureSwitchOverrideUtil.getStringFSOverrides(
        CustomizedRetrievalBasedOfflineInterestedInSource
      )

    BaseConfigBuilder()
      .set(stringFSOverrides: _*)
      .build()
  }
}
package com.twitter.cr_mixer.param

import com.twitter.finagle.stats.NullStatsReceiver
import com.twitter.logging.Logger
import com.twitter.timelines.configapi.BaseConfig
import com.twitter.timelines.configapi.BaseConfigBuilder
import com.twitter.timelines.configapi.FSEnumParam
import com.twitter.timelines.configapi.FSName
import com.twitter.timelines.configapi.FSParam
import com.twitter.timelines.configapi.FeatureSwitchOverrideUtil
import com.twitter.timelines.configapi.Param
import com.twitter.usersignalservice.thriftscala.SignalType

object VideoViewTweetsParams {
  object EnableSourceParam
      extends FSParam[Boolean](
        name = "signal_videoviewtweets_enable_source",
        default = false
      )

  object EnableSourceImpressionParam
      extends FSParam[Boolean](
        name = "signal_videoviewtweets_enableimpression_source",
        default = false
      )

  object VideoViewTweetType extends Enumeration {
    protected case class SignalTypeValue(signalType: SignalType) extends super.Val
    import scala.language.implicitConversions
    implicit def valueToSignalTypeValue(x: Value): SignalTypeValue =
      x.asInstanceOf[SignalTypeValue]

    val VideoTweetQualityView: SignalTypeValue = SignalTypeValue(SignalType.VideoView90dQualityV1)
    val VideoTweetPlayback50: SignalTypeValue = SignalTypeValue(SignalType.VideoView90dPlayback50V1)
  }

  object VideoViewTweetTypeParam
      extends FSEnumParam[VideoViewTweetType.type](
        name = "signal_videoviewtweets_videoviewtype_id",
        default = VideoViewTweetType.VideoTweetQualityView,
        enum = VideoViewTweetType
      )

  val AllParams: Seq[Param[_] with FSName] =
    Seq(EnableSourceParam, EnableSourceImpressionParam, VideoViewTweetTypeParam)

  lazy val config: BaseConfig = {
    val booleanOverrides = FeatureSwitchOverrideUtil.getBooleanFSOverrides(
      EnableSourceParam,
      EnableSourceImpressionParam,
    )
    val enumOverrides =
      FeatureSwitchOverrideUtil.getEnumFSOverrides(
        NullStatsReceiver,
        Logger(getClass),
        VideoViewTweetTypeParam)

    BaseConfigBuilder()
      .set(booleanOverrides: _*)
      .set(enumOverrides: _*)
      .build()
  }

}
package com.twitter.cr_mixer.param

import com.twitter.timelines.configapi.BaseConfig
import com.twitter.timelines.configapi.BaseConfigBuilder
import com.twitter.timelines.configapi.FSBoundedParam
import com.twitter.timelines.configapi.FSName
import com.twitter.timelines.configapi.FeatureSwitchOverrideUtil
import com.twitter.timelines.configapi.Param

object RelatedVideoTweetGlobalParams {

  object MaxCandidatesPerRequestParam
      extends FSBoundedParam[Int](
        name = "related_video_tweet_core_max_candidates_per_request",
        default = 100,
        min = 0,
        max = 500
      )

  val AllParams: Seq[Param[_] with FSName] = Seq(MaxCandidatesPerRequestParam)

  lazy val config: BaseConfig = {

    val intOverrides = FeatureSwitchOverrideUtil.getBoundedIntFSOverrides(
      MaxCandidatesPerRequestParam
    )

    BaseConfigBuilder()
      .set(intOverrides: _*)
      .build()
  }
}
